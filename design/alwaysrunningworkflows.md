# Long-Running and Continuously Renewed Workflows in Temporal

A common scenario in Temporal applications is the need for long-running or practically infinite workflows. By “infinite,” we typically mean that the workflow should remain alive as long as a certain business entity exists. Examples include a customer in a system, a mortgage that can last 30 years, or a digital twin for an IoT device.

There are two primary variations of such workflows. One is a workflow that executes some business logic on a timer. A common example is a subscription workflow that sleeps, wakes up once a month, performs checks, charges the customer, and sends a notification. The second variation is an entity workflow that reacts to events. For instance, an IoT device or digital twin might receive signals or events from the device itself and update its internal state accordingly. Based on that state, it may perform some business actions.

In most practical applications, these two models are combined. Entity workflows typically loop with some timer logic and, at the same time, react to incoming events. In the IoT use case, for example, the workflow reacts to events from the device as well as external signals, such as a notification that the device needs a firmware update. In parallel, a timer might be used to periodically check the device’s status.

If the number of iterations is small—for example, a one-year subscription with no more than 12 iterations—the entire workflow can usually fit into a single execution. However, for long-running workflows such as a 30-year mortgage, it is easy to exceed workflow limits, such as the total number of events (default limit is 50,000), the total payload size, or the number of executed activities. Longer histories also slow down recovery, as the full history must be replayed when a workflow is evicted from cache. Therefore, it is often preferable to keep workflow histories much shorter than the hard limits.

The standard solution to this problem is to use the `ContinueAsNew` operation. The idea is simple: close the current workflow and start a new one with the same Workflow ID. This operation must be implemented on the server side to meet a few important constraints. A new workflow with the same ID cannot be started while the previous one is still running. Additionally, we must guarantee that the new execution is started atomically as the old one is closed, preventing any possibility of a gap where neither is running. This atomicity ensures that no other process can start a workflow with the same ID in the meantime.

Because the previous workflow execution is being closed, it cannot continue running activities or waiting on child workflows. If child workflows are involved, they must be abandoned. Furthermore, all necessary information from the previous execution must be passed as input to the new workflow. Unless offloaded to external storage, this limits the workflow state to 2MB, which is the maximum size of the workflow input.

Most entity workflows that react to events and use timers already follow a looping structure. Their state is typically straightforward, and their logic runs activities or child workflows, then waits on a timer or signal. Adding `ContinueAsNew` in this case is generally easy—just collect the current state into a data structure and pass it as input to the next execution.

An important property of `ContinueAsNew` is that when a child workflow uses it, the parent is not notified. The parent only receives a signal when the child workflow completes or fails. A child can call `ContinueAsNew` 10,000 times, and the parent will still be waiting. Only when the final execution completes will the parent be notified. This allows `ContinueAsNew` to be used as an internal implementation detail of the child, completely hidden from the parent. The same behavior applies to Nexus operations implemented as workflows. The operation will only complete when the workflow ultimately completes or fails, regardless of how many times it has continued as new.

A notable technical detail of `ContinueAsNew` is that there is no requirement that the new workflow be of the same type. You can continue as new into a different workflow type. This is useful when you want the initial workflow to have a clean signature, while the continued workflow receives additional arguments such as internal state. This pattern is similar to how recursive functions are often implemented with a public entry point that calls an internal helper function with more parameters.

A common question is how frequently to call `ContinueAsNew`. There is no universal answer, but most SDKs provide the `ContinueAsNew`Suggested API, which is helpful when waiting on some condition. You can include this check as part of that condition. Additionally, most SDKs (except Go) provide an allHandlersFinished API, which returns true when no signal or update handlers are currently executing. Since you generally don’t want to call `ContinueAsNew` while such handlers are still running, combining these two APIs helps determine the right moment to safely continue.