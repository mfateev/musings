A frequent confusion among new users is the distinction between determinism and the ability to include complex conditional or dynamic logic within a workflow. I’ve seen cases where someone asked, “Can I run an if-else statement inside a workflow?”—with the context being a concern that it might break determinism.

Determinism is about excluding all external non-deterministic inputs. If a workflow takes an input and uses that input to implement its logic—assuming the implementation uses approved Temporal APIs and abstractions—then the code is deterministic. How that code executes based on the input doesn’t matter. It can be as complex as necessary: a hardcoded sequence of steps, complex branching and conditional logic, or even fully dynamic code that interprets the input as a document.

For example, the input might contain a list of activities to execute in a specific order. Each invocation can provide a different list, and each workflow execution can run a different set of activities. As long as the input is part of the workflow’s initial input, the code remains fully deterministic because during replay it will be given the same input recorded in the workflow history.

The main reason determinism is emphasized in Temporal documentation is to ensure only approved APIs are used. Using non-deterministic sources like System.random or System.time can break workflow determinism. Temporal provides workflow-safe APIs to get the current time, random values, and UUIDs, which can be used as deterministic alternatives. In the TypeScript SDK, calling those functions directly is allowed due to its different execution model. However, in the Java SDK, asynchronous execution or multithreading must use Temporal APIs to ensure deterministic behavior, as the Temporal runtime guarantees it.

Determinism is also important because it affects how you change and upgrade workflow code. If a workflow is running and you change its implementation, you must follow certain rules to avoid breaking determinism and the replay mechanism. This is why understanding Temporal’s recovery model—and why it depends on replay and determinism—is important. Safe upgrade strategies are a separate topic, but this is the reason why you need to understand these constraints.

That said, when you’re actually designing and writing your workflows, you generally don’t need to think much about determinism or replay. These are mostly implementation details handled by the Temporal runtime. Yes, you need to use the correct APIs, but if you’re doing that, you shouldn’t worry whether an operation or condition is deterministic—because in most cases, it is. Overthinking these aspects will usually make development harder and is often irrelevant.

So again: when designing your application, think of the *workflow function as executing exactly once*. You can invoke it again with different arguments or the same arguments. We will discuss execution guarantees like workflow ID reuse policy separately. But overall, don’t think about determinism or replay while designing the application. Focus on application logic and correctness.